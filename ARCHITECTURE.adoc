= Pipeline Architecture

[plantuml]
....
!include <awslib/AWSCommon>
!include <awslib/AWSSimplified>
!include <awslib/Compute/all>
!include <awslib/Storage/all>
!include <awslib/ManagementAndGovernance/all>
!include <awslib/Database/DynamoDB>

skinparam participant {
    BackgroundColor AWS_BG_COLOR
    BorderColor AWS_BORDER_COLOR
}

skinparam BoxPadding 10

hide footbox

box "VCS Environment" #white
actor "Developer" as dev
participant "GitHub" as gh
end box

box "CI Environment" #white
participant "Continious Integration" as ci
end box

box "AWS Environment" #white
participant "<$Lambda>\nTrigger" as lambda
participant "<$SimpleStorageServiceS3>\nTerraform Artifacts" as s3
participant "<$ElasticContainerService>\nTerraform Applyer" as tf
participant "<$DynamoDB>\nApply Order" as db
participant "<$CloudWatch>\nLogs" as cw
end box

dev -> gh : Push update to master
gh -> ci : Trigger new build with deployment


ci -> ci : Create Artifact
ci -> s3 : Upload Artifact


group Deploy Test
ci -> lambda : Trigger terraform apply in test
ci -> cw : Tail logs
lambda -> db : Verify that this stage hasn't been deployed before
lambda -> tf : Start terraform
tf -> s3 : Fetch artifact
s3 -> tf : Return corresponding artifact
tf -> db : Verify artifact signature
tf -> tf : Deploy Terraform
tf -> db : Flag commit as deployed to test
tf -> ci : Indicate finished
end

group Deploy Prod

ci -> lambda : Trigger terraform apply in prod
lambda -> db : Check if test has been deployed first

alt Test has been deployed

    ci -> cw : Tail logs
    lambda -> db : Verify that this stage hasn't been deployed before
    lambda -> tf : Start terraform
    tf -> s3 : Fetch artifact
    s3 -> tf : Return corresponding artifact
    tf -> db : Verify artifact signature
    tf -> tf : Deploy Terraform
    tf -> db : Flag commit as deployed to prod
    tf -> ci : Indicate finished

else Test has not been deployed

    lambda -> ci : Failure: Test has to be deployed first

end
end

....

== Responsibilities

The principle here is to have the CI engine do the bulk of the work, and then

CircleCI::
* Responsible for the flow of integration and deployment.

AWS Pipeline::
* Responsible for actually deploying resources.
* Check if test and stage got updated before production (IMPORTANT)

== Security Conciderations

* Verify the hash of the artifact for each stage.
  The hash can't change for a deployment.

== Related resources

Check out NCSCs CI/CD security principles!
https://www.ncsc.gov.uk/collection/developers-collection/principles/secure-the-build-and-deployment-pipeline
